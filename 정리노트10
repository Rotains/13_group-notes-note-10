선택 정렬이 뭘까? 아마 선택한 부분만 정렬 되는 게 아닐까?
선택 정렬은 리스트가 가상의 벽에 의해 정렬된 리스트와 정렬되지 않는 리스트로 나뉘는 거야!
선택 정렬이면 원소가 있을 거 아니야 원소는 어떻게 돼?
선택 정렬은 진행될수록 정렬된 원소 수는 증가하고 정렬되지 않는 원소 수는 감소하지
그래서 원소가 정렬되지 않은 리스트에서 정렬된 리스트로 이동할 때마다 정렬 패스 한 번이 완료되는 거야. 
아 그러면 정렬해야 하는 데이터가 N개라면 데이터가 1개 값은 고정이니까 정렬 패스를 N-1번 반복하면 되네? 
정답이야!
그리고 선택 정렬 알고리즘을 구현하려면 반복문 2개가 필요해, 외부 반복문은 각 패스를 반복하고, 내부 반복문은 정렬되지 않은 리시트에서 가장 작은 원소를 찾거든.

버블 정렬은 뭐지 그러면? 거품이라고 해서 여러개로 나눠서 정렬한다는 건가?
설명해주지~ 버블 정렬도 정렬된 리스트와 정렬되지 않은 리시트로 나뉘어져.
버블 정렬은 가장 큰 원소를 리스트 뒤로 이동해서 정렬시켜.
그러면 응용해서 작은 원소를 앞으로 이동시켜도 최종 정렬 결과값은 같겠네?
맞아 작은 원소를 앞으로 이동하거나 큰 원소를 뒤로 이동하거나 똑같아.
원소가 비정렬 리스트에서 정렬 리스트로 이동할 때마다 정렬 패스가 한 번이 완료되거든. 이것도 그래서 선택정렬과 똑같이 n개의 데이터 정렬하려면 몇 번 반복해야할까?
정답은 n-1번 반복하면 되네!
그리고 버블 정렬도 똑같이 반복문을 2개 사용해, 외부 반복문은 각 패스를 반복하고 내부 반복문은 가장 작은 원소를 찾아 정렬되지 않은 리스트의 맨 앞으로 내보내거든
뭔가 느낌이 선택정렬이랑 비슷하면서도 다르지?
맞아, 비슷하면서도 약간 다르네.

삽입 정렬은 뭐지? 정렬할때 무언가를 삽입한다는 건가?
삽입 정렬도 마찬가지로 리스트에서 정렬된 리스트하고 정렬되지 않은 리스트로 나뉘어지겠지?
맞아. 원소가 비정렬 리스트에서 정렬 리스트로 이동할 때마다 정렬 패스가 한 번이 완료돼. 
그러면 이것도 N개의 데이터가 정렬하려면 또 정렬 패스를 N-1번 반복해야겠네?
맞아, 여기에서 삽입 정렬은 선택 정렬하고 버블 정렬에서 보여준 패턴하고 비슷해. 외부 반복문은 각 패스를 반복하고, 내부 반복문은 해당 원소의 삽입 위치를 찾아
셋다 외분 반복문은 각 패스를 반복하고 내부 반복문에서 차이가 나는구나

셀 정렬은 뭘까 대체? 표의 셀을 정렬하는건가?
삽입 정렬은 인접한 요소를 비교하여 해당 원소가 들어갈 위치를 찾아, N개의 배열을 내림차순으로 정렬할 경우 가장 작은 값이 맨뒤에 있으면 n번 비교하고 이동해야 하는데,
셀 정렬은 이러한 문제를 해결하기 위해 h만큼의 간격으로 삽입 정렬을 실행해. h 간격만큼 떨어진 요소들을 모아서 삽입 정렬을 수행하는거지
삽입 정렬 상위 버전인가?
맞아 삽입 정렬이 한 단계 더 개선된 방법이지.
찾아보니까 셀 정렬은 초기값에 따라 정렬 속도가 달라지고, 이에 따라서 많은 연구도 이루어졌다고도 하네!

퀵 정렬은 뭘까? 시간 단축을 위해 빠르게 정렬하는 건가?
맞아 좀 비슷했어. 퀵 정렬은 빠른 속도와 간단한 구현 방법으로 정렬하는 알고리즘이야.
퀵 정렬은 정렬하려는 원소 중 임의로 1개를 골라, 그런 다음 양쪽 끝에서 부터 원소들을 비교해서 작은 값을 왼쪽 원소 집합으로, 큰 값을 오른쪽 원소 집합으로 이동 시키는 거지.
만약 원소 갯수가 짝수라면 어떻게 될까?
왼쪽이나 오른쪽 상관없이 한쪽이 원소 1개를 더 가지게 되지 않을까?
맞아. 상관없이 1개를 더 가져. 그래서 왼쪽 오른쪽 원소 집합 각각은 독립적으로 퀵 정렬을 통해 원소들의 자리가 확정해가는 거지.

여기서 그러면 무엇이 제일 빨라?
빠른 속도를 위해 간단한 구현 방법을 사용하는 퀵이 제일 빠르지 않을까?
한 번 정렬 알고리즘의 성능 비교하는 코드를 해보자!
프로그램의 실행할 때마다 발생하는 난수의 패턴이 다르니까 정렬 알고리즘의 속도가 조금씩 다르게 출력되네.
그래도 정렬 속도는 역시 퀵>셸>삽입>선택>버블 순으로 빠르네
난 그럼 빠른게 좋으니까 퀵을 사용해야겠다.
